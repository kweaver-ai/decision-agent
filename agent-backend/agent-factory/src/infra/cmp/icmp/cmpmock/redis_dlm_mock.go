// Code generated by MockGen. DO NOT EDIT.
// Source: ./redis_dlm.go
//
// Generated by this command:
//
//	mockgen -source=./redis_dlm.go -destination ./cmpmock/redis_dlm_mock.go -package cmpmock
//

// Package cmpmock is a generated GoMock package.
package cmpmock

import (
	context "context"
	reflect "reflect"

	icmp "github.com/kweaver-ai/decision-agent/agent-factory/src/infra/cmp/icmp"
	gomock "go.uber.org/mock/gomock"
)

// MockRedisDlmCmp is a mock of RedisDlmCmp interface.
type MockRedisDlmCmp struct {
	ctrl     *gomock.Controller
	recorder *MockRedisDlmCmpMockRecorder
	isgomock struct{}
}

// MockRedisDlmCmpMockRecorder is the mock recorder for MockRedisDlmCmp.
type MockRedisDlmCmpMockRecorder struct {
	mock *MockRedisDlmCmp
}

// NewMockRedisDlmCmp creates a new mock instance.
func NewMockRedisDlmCmp(ctrl *gomock.Controller) *MockRedisDlmCmp {
	mock := &MockRedisDlmCmp{ctrl: ctrl}
	mock.recorder = &MockRedisDlmCmpMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRedisDlmCmp) EXPECT() *MockRedisDlmCmpMockRecorder {
	return m.recorder
}

// NewMutex mocks base method.
func (m *MockRedisDlmCmp) NewMutex(name string) icmp.RedisDlmMutexCmp {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewMutex", name)
	ret0, _ := ret[0].(icmp.RedisDlmMutexCmp)
	return ret0
}

// NewMutex indicates an expected call of NewMutex.
func (mr *MockRedisDlmCmpMockRecorder) NewMutex(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewMutex", reflect.TypeOf((*MockRedisDlmCmp)(nil).NewMutex), name)
}

// MockRedisDlmMutexCmp is a mock of RedisDlmMutexCmp interface.
type MockRedisDlmMutexCmp struct {
	ctrl     *gomock.Controller
	recorder *MockRedisDlmMutexCmpMockRecorder
	isgomock struct{}
}

// MockRedisDlmMutexCmpMockRecorder is the mock recorder for MockRedisDlmMutexCmp.
type MockRedisDlmMutexCmpMockRecorder struct {
	mock *MockRedisDlmMutexCmp
}

// NewMockRedisDlmMutexCmp creates a new mock instance.
func NewMockRedisDlmMutexCmp(ctrl *gomock.Controller) *MockRedisDlmMutexCmp {
	mock := &MockRedisDlmMutexCmp{ctrl: ctrl}
	mock.recorder = &MockRedisDlmMutexCmpMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRedisDlmMutexCmp) EXPECT() *MockRedisDlmMutexCmpMockRecorder {
	return m.recorder
}

// Lock mocks base method.
func (m *MockRedisDlmMutexCmp) Lock(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lock", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Lock indicates an expected call of Lock.
func (mr *MockRedisDlmMutexCmpMockRecorder) Lock(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lock", reflect.TypeOf((*MockRedisDlmMutexCmp)(nil).Lock), ctx)
}

// Unlock mocks base method.
func (m *MockRedisDlmMutexCmp) Unlock() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unlock")
	ret0, _ := ret[0].(error)
	return ret0
}

// Unlock indicates an expected call of Unlock.
func (mr *MockRedisDlmMutexCmpMockRecorder) Unlock() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unlock", reflect.TypeOf((*MockRedisDlmMutexCmp)(nil).Unlock))
}
