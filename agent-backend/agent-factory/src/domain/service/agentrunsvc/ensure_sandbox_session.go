package agentsvc

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/kweaver-ai/decision-agent/agent-factory/src/drivenadapter/httpaccess/sandboxplatformhttp/sandboxplatformdto"
	agentreq "github.com/kweaver-ai/decision-agent/agent-factory/src/driveradapter/api/rdto/agent/req"
	o11y "github.com/kweaver-ai/kweaver-go-lib/observability"
	"github.com/pkg/errors"
	"net/http"
)

// EnsureSandboxSession 确保 Sandbox Session 存在并就绪
// 完全移除 sync.Map 缓存，每次直接调用 Sandbox Platform 检测
func (s *agentSvc) EnsureSandboxSession(ctx context.Context, sessionID string, req *agentreq.ChatReq) (string, error) {
	ctx, _ = o11y.StartInternalSpan(ctx)
	defer o11y.EndSpan(ctx, nil)

	o11y.SetAttributes(ctx,
		o11y.String("session_id", sessionID),
		o11y.String("user_id", req.UserID),
		o11y.String("agent_id", req.AgentID),
	)

	// 1. 检测 Session 状态
	sessionInfo, err := s.sandboxPlatform.GetSession(ctx, sessionID)
	if err != nil {
		if s.isSessionNotFoundError(err) {
			o11y.SetAttributes(ctx, o11y.String("action", "create_new"))
			return s.createNewSession(ctx, sessionID, req)
		}

		o11y.SetAttributes(ctx, o11y.String("action", "recover_from_error"))
		s.logger.Warnf("[EnsureSandboxSession] get session failed: %v, will create new session", err)
		return s.createNewSession(ctx, sessionID, req)
	}

	// 2. 检查 Session 状态
	if sessionInfo.Status == "running" {
		o11y.SetAttributes(ctx, o11y.String("action", "reuse_existing"))
		s.logger.Infof("[EnsureSandboxSession] reuse existing session: %s", sessionID)
		return sessionID, nil
	}

	o11y.SetAttributes(ctx, o11y.String("action", "recreate"))
	s.logger.Warnf("[EnsureSandboxSession] session status is %s, will recreate: %s", sessionInfo.Status, sessionID)
	return s.createNewSession(ctx, sessionID, req)
}

// createNewSession 创建新的 Sandbox Session
func (s *agentSvc) createNewSession(ctx context.Context, sessionID string, req *agentreq.ChatReq) (string, error) {
	createReq := sandboxplatformdto.CreateSessionReq{
		UserID:           req.UserID,
		AgentID:          req.AgentID,
		BusinessDomainID: req.XBusinessDomainID,
		Config: map[string]interface{}{
			"session_id": sessionID,
			"file_upload_config": map[string]interface{}{
				"max_file_size":      s.sandboxPlatformConf.DefaultFileUploadConfig.MaxFileSize,
				"max_file_size_unit": s.sandboxPlatformConf.DefaultFileUploadConfig.MaxFileSizeUnit,
				"max_file_count":     s.sandboxPlatformConf.DefaultFileUploadConfig.MaxFileCount,
				"allowed_file_types": s.sandboxPlatformConf.DefaultFileUploadConfig.AllowedFileTypes,
			},
		},
	}

	createResp, err := s.sandboxPlatform.CreateSession(ctx, createReq)
	if err != nil {
		if s.isSessionAlreadyExistsError(err) {
			s.logger.Infof("[createNewSession] session already exists: %s, will wait for ready", sessionID)
			return s.waitForSessionReady(ctx, sessionID)
		}

		s.logger.Errorf("[createNewSession] create failed: %v", err)
		return "", errors.Wrap(err, "create sandbox session failed")
	}

	actualSessionID := createResp.SessionID
	if createResp.SessionID == "" {
		actualSessionID = sessionID
	}

	return s.waitForSessionReady(ctx, actualSessionID)
}

// waitForSessionReady 等待 Session 就绪
func (s *agentSvc) waitForSessionReady(ctx context.Context, sessionID string) (string, error) {
	maxRetries := s.sandboxPlatformConf.MaxRetries
	retryInterval := s.sandboxPlatformConf.RetryInterval
	retryIntervalDuration, err := time.ParseDuration(retryInterval)
	if err != nil {
		s.logger.Warnf("[waitForSessionReady] failed to parse retry interval, using default 500ms")
		retryIntervalDuration = 500 * time.Millisecond
	}

	for i := 0; i < maxRetries; i++ {
		sessionInfo, err := s.sandboxPlatform.GetSession(ctx, sessionID)
		if err != nil {
			s.logger.Errorf("[waitForSessionReady] get session status failed (attempt %d): %v", i+1, err)
			time.Sleep(retryIntervalDuration)
			continue
		}

		if sessionInfo.Status == "running" {
			s.logger.Infof("[waitForSessionReady] session ready: %s (attempts: %d)", sessionID, i+1)
			return sessionID, nil
		}

		if sessionInfo.Status == "error" || sessionInfo.Status == "stopped" {
			return "", errors.Errorf("session in invalid state: %s", sessionInfo.Status)
		}

		time.Sleep(retryIntervalDuration)
	}

	return "", errors.New("timeout waiting for session ready")
}

// isSessionNotFoundError 判断是否为 Session 不存在的错误
func (s *agentSvc) isSessionNotFoundError(err error) bool {
	var httpErr *rest.HTTPError
	if errors.As(err, &httpErr) {
		return httpErr.StatusCode == http.StatusNotFound
	}
	return false
}

// isSessionAlreadyExistsError 判断是否为 Session 已存在的错误
func (s *agentSvc) isSessionAlreadyExistsError(err error) bool {
	var httpErr *rest.HTTPError
	if errors.As(err, &httpErr) {
		return httpErr.StatusCode == http.StatusConflict
	}
	return strings.Contains(err.Error(), "already exists")
}
